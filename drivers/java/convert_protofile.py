#!/usr/bin/env python

'''
Generates AST terms and serialization code for the Java driver
'''

import re
import os
import json
import codecs
import datetime
import os.path

from collections import OrderedDict
from mako.lookup import TemplateLookup

PACKAGE_DIR = './src/main/java/com/rethinkdb'
TEMPLATE_DIR = './templates'
PROTO_DIR = PACKAGE_DIR + '/proto'
PROTO_FILE = '../../src/rdb_protocol/ql2.proto'
PROTO_JSON = './proto_basic.json'


def main():
    proto = get_proto_def()
    term_meta = get_term_metadata()
    render_enums(proto)
    render_rqlquery_class(term_meta)


def camel(varname):
    return ''.join(x.title() for x in varname.split('_'))


def dromedary(words):
    broken = words.split('_')
    return broken[0].lower() + ''.join(x.title() for x in broken[1:])


def autogenerated_header(template_path, output_path):
    rel_tpl = os.path.relpath(template_path, start=output_path)

    return ('// Autogenerated by {} at {}.\n'
            '// Do not edit this file directly.\n'
            '// The template for this file is located at:\n'
            '// {}\n').format(
        __file__[2:], datetime.date.today(), rel_tpl)


def get_proto_def():
    '''Get protocol definition json as a dictionary'''
    if not os.path.isfile(PROTO_JSON):
        print "proto_basic.json doesn't exist. creating from scratch"
        with open(PROTO_FILE) as ql2:
            proto = Proto2Dict(ql2)()
        with codecs.open(PROTO_JSON) as pb:
            json.dump(proto, pb, indent=2)
        return proto
    else:
        return json.load(
            codecs.open("proto_basic.json", "r", "utf-8"),
            object_pairs_hook=OrderedDict,
        )


def get_term_metadata():
    '''Gets some extra metadata needed to fully generate terms'''
    with codecs.open('./term_info.json', "r", 'utf-8') as f:
        return json.load(f, object_pairs_hook=OrderedDict)


# Used in parsing protofile
MESSAGE_REGEX = re.compile('\s*(message|enum) (?P<name>\w+) \{')
VALUE_REGEX = re.compile('\s*(?P<name>\w+)\s*=\s*(?P<value>\w+)')
END_REGEX = re.compile('\s*\}')


class Proto2Dict(object):
    def __init__(self, input_file):
        self._in = input_file
        self.d = OrderedDict()
        self.parents = []

    def __call__(self):
        for line in self._in:
            (self.match_message(line) or
             self.match_value(line) or
             self.match_end(line))
        while self.parents:
            self.pop_stack()
        return self.d

    def push_message(self, name):
        new_level = OrderedDict()
        self.d[name] = new_level
        self.parents.append(self.d)
        self.d = new_level

    def pop_stack(self):
        self.d = self.parents.pop()

    def match_message(self, line):
        match = MESSAGE_REGEX.match(line)
        if match is None:
            return False
        self.push_message(match.group('name'))
        return True

    def match_value(self, line):
        match = VALUE_REGEX.match(line)
        if match is None:
            return False
        self.d[match.group('name')] = int(match.group('value'), 0)
        return True

    def match_end(self, line):
        if END_REGEX.match(line):
            self.pop_stack()
            return True
        else:
            return False


TL = TemplateLookup(directories=[TEMPLATE_DIR])

template_context = {
    'camel': camel,  # CamelCase function
    'dromedary': dromedary,  # dromeDary case function
}


def render(template_name, output_dir, output_name=None, **kwargs):
    if output_name is None:
        output_name = template_name

    tpl = TL.get_template(template_name)
    output_path = output_dir + '/' + output_name
    with codecs.open(output_path, "w", "utf-8") as outfile:
        print "Rendering", output_path
        results = template_context.copy()
        results.update(kwargs)
        rendered = tpl.render(**results)
        outfile.write(autogenerated_header(
            TEMPLATE_DIR + '/' + template_name,
            output_path,
        ))
        outfile.write(rendered)


def render_enums(proto):
    '''Render protocol enums'''
    render_enum("Version", proto["VersionDummy"]["Version"])
    render_enum("Protocol", proto["VersionDummy"]["Protocol"])
    render_enum("QueryType", proto["Query"]["QueryType"])
    render_enum("FrameType", proto["Frame"]["FrameType"])
    render_enum("ResponseType", proto["Response"]["ResponseType"])
    render_enum("ResponseNote", proto["Response"]["ResponseNote"])
    render_enum("DatumType", proto["Datum"]["DatumType"])
    render_enum("TermType", proto["Term"]["TermType"])


def render_enum(classname, mapping):
    render("Enum.java",
           PROTO_DIR,
           output_name=classname+'.java',
           classname=classname,
           items=mapping.items(),
           )


def render_rqlquery_class(term_meta):
    render("RqlQuery.java",
           PACKAGE_DIR+'/ast',
           meta=term_meta)


if __name__ == '__main__':
    main()
